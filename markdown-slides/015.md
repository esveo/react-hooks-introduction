# useDebounce

- ðŸ§­ Erstelle eine neue Datei: `useDebouncedValue.ts`
- ðŸ’ª Implementiere eine Hook `function useDebouncedValue<TValue>(value: TValue, timeInMs: number): TValue { ... }`:
  - Diese hÃ¤lt einen state `debouncedValue`, der mit `value` initialisiert wird
  - Zudem wird ein effect definiert, der bei jeder Ã„nderung von `value` einen timeout mit der LÃ¤nge `timeInMs` startet. Nachdem dieser Timeout abgelaufen ist, wird der aktuelle `value`-Wert in `debouncedValue` Ã¼bertragen.
    - Achte darauf, dass du den timeout abrichst (mit `clearTimeout(...)`), wenn sich `value` nochmals Ã¤ndert.

```tsx
/**
 * Nimmt einen sich Ã¤ndernden Wert entgegen und sorgt dafÃ¼r, dass Ã„nderungen abgebremst werden.
 * Nach einer Ã„nderung wird `timeInMs` Millisekunden gewartet, bis der Wert in debounced
 * Ã¼bernommen wird und als Resultat von der Hook zurÃ¼ckgegeben wird.
 */
export function useDebouncedValue<TValue>(
  value: TValue,
  timeInMs: number
): TValue {
  // ...
}
```

- ðŸ’ª Nutze die Hook in `UserList.tsx`, damit die Requests erst nach 500ms abgeschickt werden.
